<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ay&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Ay&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 27 Dec 2020 16:01:23 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JavaScript的诞生</title>
      <link>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
      <pubDate>Sun, 27 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/javascript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
      
        <description>&lt;h1 id=&#34;javascript的诞生&#34;&gt;JavaScript的诞生&lt;/h1&gt;
&lt;p&gt;1995年，布兰登艾克在网景公司为浏览器开发了JS功能（设计时间为10天），是与Java搭配使用的辅助脚本语言并且语法上有些类似的，能够使得非专业的网页作者也能很快上手。JS最初的命名为：Mocha，于95年底改名为LiveScript，同年12月，Netscape Navigator 2.0 Beta 3中部署时被重命名&lt;strong&gt;JavaScript&lt;/strong&gt;，当时网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上Java这个编程语言“热词”，因此将其临时改名为JavaScript，日后这成为大众对这门语言有诸多误解的原因之一。&lt;/p&gt;
&lt;p&gt;1996年11月，网景公司向ECMA提交了语言标准，由于版权问题，JS的语言标准叫做ECMAScript。俗称ES。他打击了1996年8月微软发布的IE3中的JScript。&lt;/p&gt;
&lt;p&gt;一般来说，完整的JavaScript包括以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ECMAScript，描述了该语言的语法和基本对象&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ECMAScript于1997年6月诞生了第一版。&lt;/li&gt;
&lt;li&gt;1999年12月诞生了第三版（IE6最流行的版本）&lt;/li&gt;
&lt;li&gt;第四版流产&lt;/li&gt;
&lt;li&gt;2009年2月发布了第五版&lt;/li&gt;
&lt;li&gt;2015年6月发布了第六版&lt;/li&gt;
&lt;li&gt;此后的每一年都发布一个新版本，并且以年份命名版本号&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;文档对象模型（&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/DOM&#34;&gt;DOM&lt;/a&gt;），描述处理&lt;strong&gt;网页内容&lt;/strong&gt;的方法和接口&lt;/li&gt;
&lt;li&gt;浏览器对象模型（&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B&#34;&gt;BOM&lt;/a&gt;），描述与&lt;strong&gt;浏览器&lt;/strong&gt;进行交互的方法和接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JavaScript的基本特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种解释性脚本语言（代码不进行预编译）。&lt;/li&gt;
&lt;li&gt;主要用来向HTML页面添加&lt;strong&gt;交互行为&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JavaScript常用来完成以下任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;嵌入动态文本于HTML页面&lt;/li&gt;
&lt;li&gt;对浏览器事件作出响应&lt;/li&gt;
&lt;li&gt;读写HTML元素&lt;/li&gt;
&lt;li&gt;在数据被提交到服务器之前验证数据&lt;/li&gt;
&lt;li&gt;检测访客的浏览器信息&lt;/li&gt;
&lt;li&gt;控制&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Cookie&#34;&gt;cookies&lt;/a&gt;，包括创建和修改等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;js的设计缺陷&#34;&gt;JS的设计缺陷&lt;/h3&gt;
&lt;p&gt;缺陷产生的原因：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 设计阶段过于仓促&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的设计只用了十天。&lt;/p&gt;
&lt;p&gt;另一方面，这种语言的设计初衷，是为了解决一些简单的网页互动（比如，检查&amp;quot;用户名&amp;quot;是否填写），并没有考虑复杂应用的需要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 没有先例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Javascript同时结合了函数式编程和面向对象编程的特点，这很可能是历史上的第一例。而且直到今天为止，Javascript仍然是世界上唯一使用&lt;a href=&#34;https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&#34;&gt;Prototype继承模型&lt;/a&gt;的主要语言。这使得它没有设计先例可以参考。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 过早的标准化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Javascript的发展非常快，根本没有时间调整设计。&lt;/p&gt;
&lt;p&gt;1995年5月，设计方案定稿；10月，解释器开发成功；12月，向市场推出，立刻被广泛接受，全世界的用户大量使用。Javascript缺乏一个从小到大、慢慢积累用户的过程，而是连续的爆炸式扩散增长。大量的既成网页和业余网页设计者的参与，使得调整语言规格困难重重。更糟的是，Javascript的规格还没来及调整，就固化了。&lt;/p&gt;
&lt;p&gt;1996年8月，微软公司强势介入，宣布推出自己的脚本语言Jscript；11月，为了压制微软，网景公司决定申请JavaScript的国际标准；1997年6月，第一个国际标准ECMA-262正式颁布。设计缺陷还没有充分暴露就成了标准。&lt;/p&gt;
&lt;p&gt;但是，尽管如此，JavaScript依然是目前编程能力很强大的一门语言，他有广泛的使用性。他也是网页编程的唯一语言。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/JavaScript#%E5%8E%86%E5%8F%B2&#34;&gt;JavaScrpit的历史&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html&#34;&gt;Javascript诞生记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/06/10_design_defects_in_javascript.html&#34;&gt;Javascript的10个设计缺陷&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h1 id=&#34;css知识总结&#34;&gt;CSS知识总结&lt;/h1&gt;
&lt;h2 id=&#34;浏览器渲染原理&#34;&gt;浏览器渲染原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据HTML构建HTML树（DOM）&lt;/li&gt;
&lt;li&gt;根据CSS构建CSS树（CSSDOW）&lt;/li&gt;
&lt;li&gt;将两棵树合并成一颗渲染树(Render Tree)&lt;/li&gt;
&lt;li&gt;Layout布局（文档流、盒模型、计算大小和位置）&lt;/li&gt;
&lt;li&gt;Paint绘制（把边框颜色、文字颜色、阴影等画出来）&lt;/li&gt;
&lt;li&gt;Compose合成（根据层叠关系展示画面）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DOM,CSSOM,Render Tree&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/21/zlycZ8CeEsuRwYi.png&#34; alt=&#34;tree&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;transition和animationcss动画&#34;&gt;Transition和Animation（CSS动画）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;语法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;transition: 属性名 时长 过渡方式 延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如： transition: all 2s ease 2s;&lt;/p&gt;
&lt;p&gt;其中过渡方式有: linear/ease/ease-in/ease-out/ease-in-out&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#heart{
  display: inline-block;
  margin: 100px;
  position: relative;
  transition: all 1s; 
}
#heart:hover{
  transform: scale(1.5); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;http://js.jirengu.com/nonud/1/edit?html,css,output&#34;&gt;代码1&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;animation:时长 过渡方式 延迟 次数 方向 填充模式 是否暂停 动画名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如： animation: .5s heart infinite alternate-reverse;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#heart{
  display: inline-block;
  margin: 100px;
  position: relative;
  animation: .5s heart infinite alternate-reverse;
}
@keyframes heart {
  0%{
    transform: scale(1);
  }
  100%{
    transform: scale(1.2);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;http://js.jirengu.com/hosug/1/edit?html,css,output&#34;&gt;代码2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;资料来源：饥人谷&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML 常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>&lt;h1 id=&#34;html-常用标签&#34;&gt;HTML 常用标签&lt;/h1&gt;
&lt;h2 id=&#34;a-标签111&#34;&gt;a 标签（11.1）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;网址&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://baidu.com&#34;&gt;http://baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baidu.com&#34;&gt;https://baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;//baidu.com (推荐这种，因为浏览器会自动适配网站)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;路径&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;/a/b/c 和 a/b/c 的区别： /a 是把当前 http 服务的根目录，如果不是用服务器打开而是双击打开.html 文件的话就会找不到文件; a 是在当前目录下找这个文件&lt;/li&gt;
&lt;li&gt;index.html 和./index.html 无区别&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;伪协议&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;javascript: ;&lt;/li&gt;
&lt;li&gt;id(#id 号)&lt;/li&gt;
&lt;li&gt;mailto:邮箱地址&lt;/li&gt;
&lt;li&gt;tel:手机号&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;target&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;_blank 新建空网站&lt;/li&gt;
&lt;li&gt;_top 顶部网站&lt;/li&gt;
&lt;li&gt;_self 当前网站&lt;/li&gt;
&lt;li&gt;_praent 父类网站&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;table-标签112&#34;&gt;table 标签（11.2）&lt;/h2&gt;
&lt;p&gt;thead 表头&lt;/p&gt;
&lt;p&gt;tbody 表体&lt;/p&gt;
&lt;p&gt;tfoot 表底&lt;/p&gt;
&lt;p&gt;tr 表换行&lt;/p&gt;
&lt;p&gt;th 表标题&lt;/p&gt;
&lt;p&gt;td 表数据&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;img-标签113&#34;&gt;img 标签（11.3）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;属性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;alt/weight/height/src&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;onload/onerror&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;max-width:100% (手机端可以有较好体验)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;小笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;table{&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;border-collapse:collapse;&lt;/p&gt;
&lt;p&gt;border-spacing:0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以让表格合并，变好看一点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input 和 button 区别：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;button 里面可以加其他标签，添加样式，input 不可以&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java Collection</title>
      <link>http://localhost:1313/post/java-collection/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-collection/</guid>
      
        <description>&lt;h1 id=&#34;map集合和collection集合类总结&#34;&gt;Map集合和Collection集合类总结&lt;/h1&gt;
&lt;p&gt;Java的数组有很多弊端：长度固定，不可增删，只能存储同一种数据类型，数组内元素的内存空间是连续分配的，对内存要求高。 而Java中的集合弥补了这一点，在Java中的集合可以分为两大类&lt;code&gt;Collection&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;, 对此基于我们不同的需求可以产生不同的实现。&lt;/p&gt;
&lt;h1 id=&#34;collection单列集合&#34;&gt;Collection（单列集合）&lt;/h1&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;List接口是一个有序集合，允许有相同的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arraylist是最常用的实现类，拥有线性结构，本质上就是一个数组，通过动态扩容实现添加元素（创建一个1.5x的空间，把原先的所有元素拷贝过去）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LinkedList底层为链表，特点是分配内存空间不是必须连续的、插入，删除操作也很快，只要修改前后指针，时间复杂度为O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist和linkedlist区别&#34;&gt;ArrayList和LinkedList区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ArrayList是实现&lt;strong&gt;基于动态数组&lt;/strong&gt;的数据结构，而LinkedList是&lt;strong&gt;基于链表&lt;/strong&gt;的数据结构&lt;/li&gt;
&lt;li&gt;对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList需要移动指针&lt;/li&gt;
&lt;li&gt;对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList需要移动数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;没有顺序，不能包含重复元素&lt;/p&gt;
&lt;h3 id=&#34;hashset&#34;&gt;HashSet&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashSet中不能包含重复元素，可以有NULL元素，存入的元素是无序的&lt;/li&gt;
&lt;li&gt;HashSet底层结构是哈希表，确认唯一性的两个方法是 HashCode()/equals()方法&lt;/li&gt;
&lt;li&gt;添加删除时间复杂度都是O（1）&lt;/li&gt;
&lt;li&gt;非线性安全&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;linkedhashset&#34;&gt;LinkedHashSet&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;LinkedHashSet中不能包含重复元素，可以有NULL元素，存入的元素是按照放入顺序排列&lt;/li&gt;
&lt;li&gt;底层结构是哈希表和链表，链表保证了数据存储和取出一致，哈希表保证了元素的唯一性&lt;/li&gt;
&lt;li&gt;添加删除时间复杂度都是O(1)&lt;/li&gt;
&lt;li&gt;非线性安全&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mapkey-value集合&#34;&gt;Map(key-value集合)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Map即为映射，不能有重复的key，可以有重复的value(例如ID和name)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hashmap&#34;&gt;HashMap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashMap 是一个散列表，它存储的内容是键值对(key-value)映射&lt;/li&gt;
&lt;li&gt;HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口&lt;/li&gt;
&lt;li&gt;HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;treemap&#34;&gt;TreeMap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;TreeMap 是一个有序的key-value集合，它是通过红黑树实现的&lt;/li&gt;
&lt;li&gt;TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合&lt;/li&gt;
&lt;li&gt;TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合&lt;/li&gt;
&lt;li&gt;TreeMap 实现了Cloneable接口，意味着它能被克隆&lt;/li&gt;
&lt;li&gt;TreeMap 实现了java.io.Serializable接口，意味着它支持序列化&lt;/li&gt;
&lt;li&gt;TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>HTML 入门笔记</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Sat, 05 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>&lt;h1 id=&#34;html-入门笔记-1&#34;&gt;HTML 入门笔记 1&lt;/h1&gt;
&lt;p&gt;HTML = Hypertext Markup language 超文本标记语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超文本标记语言是一种用于创建网页的标准标记语言。HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取 HTML 文件，并将其渲染成可视化网页。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 发明者：Tim Berners Lee&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;李爵士自己做了一个浏览器，自己写了一个服务器，是前端工程师的祖师爷&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 起手式：Emmet ！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 Index.html 文件，用 IDE 打开之后输入 &lt;code&gt;！+Tab&lt;/code&gt; , IDE 会补全代码，具体如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/18/MbIRh5ex8gda74y.png&#34; alt=&#34;Capture&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;lang=&amp;quot;en&amp;quot;&lt;/code&gt; 可以改成&lt;code&gt;lang = &amp;quot;zh-CN&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;HTML 常见章节标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;h1~h6: 标题 1-标题 6 数字越大字越小&lt;/li&gt;
&lt;li&gt;section：章节&lt;/li&gt;
&lt;li&gt;acticle: 文章&lt;/li&gt;
&lt;li&gt;main：主要内容&lt;/li&gt;
&lt;li&gt;aside: 旁支内容&lt;/li&gt;
&lt;li&gt;p：段落&lt;/li&gt;
&lt;li&gt;header,footer：头部和尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 全局属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class 类&lt;/li&gt;
&lt;li&gt;contenteditable 可编辑&lt;/li&gt;
&lt;li&gt;hidden 隐藏&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;style 样式&lt;/li&gt;
&lt;li&gt;tabindex：为数字，一般数字大小决定按 Tab 后选中顺序，-1 为永不选中，0 为最后选中&lt;/li&gt;
&lt;li&gt;title 鼠标移上去显示的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 常用内容标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 链接&lt;/li&gt;
&lt;li&gt;em 语气强调&lt;/li&gt;
&lt;li&gt;strong 重点强调&lt;/li&gt;
&lt;li&gt;code 显示代码&lt;/li&gt;
&lt;li&gt;pre 显示空白符&lt;/li&gt;
&lt;li&gt;q 引用&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Mavren 和Java 包管理区别</title>
      <link>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 05 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</guid>
      
        <description>&lt;h1 id=&#34;jvm工作原理&#34;&gt;JVM工作原理&lt;/h1&gt;
&lt;p&gt;首先，我们先来了解一下JVM的工作原理，其实简单地概括性地说，JVM只会做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行一个类的字节码&lt;/li&gt;
&lt;li&gt;在执行这个类的字节码的时候，若碰到了新的类，则加载它&lt;/li&gt;
&lt;li&gt;不断重复以上两个过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见，JVM的工作是如此的简单和枯燥，可是JVM是怎么知道在哪里读取这些类的呢？
JVM是通过&lt;code&gt;classpath&lt;/code&gt;参数来获取到这个路径的。
你没有给JVM传递classpath这个参数，但是你的编译器偷偷帮你干了这件事情了！&lt;/p&gt;
&lt;p&gt;每次用编译器编译的时候，控制台都会有一串命令，在命令里面你可以清楚地看到编译器给JVM偷偷传递了&lt;code&gt;classpath&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;另外，由于一个包有可能又依赖于其他很多个包，因此一个项目下来，可能&lt;code&gt;classpath&lt;/code&gt;下的依赖路径会变得又臭又长。
在Java刚诞生的时候，人们是需要通过手写这些&lt;code&gt;classpath&lt;/code&gt;路径来让JVM读懂读取jar包（一堆类的集合）的路径的，后面再人们的不断努力下，强大的IDEA和Maven的诞生，才让这个繁琐的过程变得无比简单&lt;/p&gt;
&lt;h1 id=&#34;classpath-hell&#34;&gt;Classpath hell&lt;/h1&gt;
&lt;p&gt;在Maven诞生之前，依赖冲突是一个很容易发生且很难解决的问题，我们把这种依赖冲突又称为&lt;code&gt;classpath hell&lt;/code&gt;（也叫依赖地狱）
什么是依赖冲突，由于全限定类名是类的唯一标示，因此当多个同名类不同版本同时出现在classpath的时候，就是噩梦的开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图，A包依赖了B包和C2包，而B包又依赖了C1包，在这个时候，由于所有的依赖包的路径都会写在classpath上面，让JVM从前往后地在这些路径上面寻早需要的依赖包，因此，若JVM先读取到了C1依赖包的classpath路径，那么C2这个依赖包，由于和C1只是版本上面的不同，因此JVM会误把C1路径中找到的依赖包也同样作用在C2上面，从而导致出现不可预期的错误。
一般来说，当你看到你的代码在编译运行之后，出现了以下的错误，那就代表最麻烦的包冲突出现了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AbstractMethodError&lt;/li&gt;
&lt;li&gt;NoClassDefFoundError&lt;/li&gt;
&lt;li&gt;ClassNotFoundException&lt;/li&gt;
&lt;li&gt;LinkageError&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;maven包管理的原理&#34;&gt;Maven包管理的原理&lt;/h1&gt;
&lt;p&gt;在Maven没有诞生之前，包冲突只能通过手动寻找冲突的包依赖，并把对应的包进行升级或者替换，但问题是，一个项目一般存在着很多很多的包依赖，手动寻找费时费力，效率太低。直到后来Maven的诞生，才使得解决包依赖的解决变得不再那么麻烦。&lt;/p&gt;
&lt;p&gt;首先我们先来了解一下Maven是如何对包进行管理的
我们需要首先知道的是，Maven有一套约定俗成的规范，其中规定了，生产代码需要放在&lt;code&gt;src/main&lt;/code&gt;目录下面，而测试代码则需要放在test/main目录下面。这个将在之后讲包管理的scope中有用。&lt;/p&gt;
&lt;p&gt;Maven会有中央仓库和本地仓库两个仓库
本地仓库即字面意思在本地你电脑中存在的仓库，它默认位于&lt;code&gt;~/.m2&lt;/code&gt;目录中，里面会放置一些经过下载的第三方包的缓存。
而中央仓库即线上仓库的意思，一个包会含有&lt;code&gt;groupId&lt;/code&gt;、&lt;code&gt;artifactId&lt;/code&gt;、&lt;code&gt;version&lt;/code&gt;三个字段，因此在中央仓库中，一个包存放的路径也是以这三个字段来存放的，具体会存放在&lt;code&gt;groupId/artifactId/version&lt;/code&gt;这个位置。&lt;/p&gt;
&lt;p&gt;当一个项目需要使用一些第三方包的时候，你可以在pom文件中添加这些包的信息，这样Maven就会自动帮你下载这些包以及其相关依赖包到本地中缓存起来&lt;/p&gt;
&lt;h1 id=&#34;maven如何解决包冲突&#34;&gt;Maven如何解决包冲突&lt;/h1&gt;
&lt;p&gt;解决包冲突的一个原则：绝对不允许最终的classpath出现同名不同版本的jar包&lt;/p&gt;
&lt;p&gt;在Maven中，当出现包冲突的问题的时候，Maven会保留离项目最近的包，而去除其他有冲突的包，拿之前的例子来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。但是这种策略有时候是不完美的，因此有时候也需要我们人为地去维护它，但不管怎么说，由于Maven的诞生，使得我们对于第三方包的很多操作都变得轻松和简单了。&lt;/p&gt;
&lt;p&gt;接下来我们来说一下人为解决冲突的三种办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接依赖高版本依赖，这样Maven就能去除所有低版本的不合适的依赖了&lt;/li&gt;
&lt;li&gt;通过pom文件来排除包中的后代指定依赖&lt;/li&gt;
&lt;li&gt;通过Maven helper插件来解决包冲突问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pom文件中，可以通过设置scope标签，来指定一个包是否可以被生产代码和测试代码所引用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;complie（生产代码以及测试代码均可见）&lt;/li&gt;
&lt;li&gt;test（只有测试代码可见）&lt;/li&gt;
&lt;li&gt;provided（只在编译的生产代码的时候生效，在运行时无效）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>如何用 hugo 搭建个人博客</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 02 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;h1 id=&#34;步骤1安装-hugo&#34;&gt;步骤1：安装 hugo&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;brew install hugo
# or
port install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认你的安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤2-创建新网站&#34;&gt;步骤2: 创建新网站&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new site quickstart
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤3-添加主题&#34;&gt;步骤3: 添加主题&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cd quickstart
git init
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤4-添加内容&#34;&gt;步骤4： 添加内容&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/&amp;lt;name&amp;gt;.md
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤5-开始hugo-server&#34;&gt;步骤5: 开始hugo server&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo server -D
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;新站点是http://localhost:1313/.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;步骤6自定义你的主题&#34;&gt;步骤6：自定义你的主题&lt;/h1&gt;
&lt;p&gt;打开config.toml文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseURL = &amp;quot;https://example.org/&amp;quot;    #你的github个人主页
languageCode = &amp;quot;en-us&amp;quot;              #语言
title = &amp;quot;My New Hugo Site&amp;quot;          #标题
theme = &amp;quot;ananke&amp;quot;                    #主题
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤7-创建静态页面&#34;&gt;步骤7： 创建静态页面&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo -D
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤8创建github个人页面仓库&#34;&gt;步骤8：创建Github个人页面仓库&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;创建新仓库名为 &amp;lt;你的github名&amp;gt;.github.io&lt;/li&gt;
&lt;li&gt;在public文件中使用cmder运行：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git init
git add .
git commit -v/m
git remote xxxx
git push xxxx
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>DOM事件机制和事件委托</title>
      <link>http://localhost:1313/post/dom%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</link>
      <pubDate>Thu, 23 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/dom%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</guid>
      
        <description>&lt;h1 id=&#34;dom事件机制和事件委托&#34;&gt;DOM事件机制和事件委托&lt;/h1&gt;
&lt;h1 id=&#34;一简介&#34;&gt;一、简介&lt;/h1&gt;
&lt;p&gt;事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在DOM中两种不同的传播方式。&lt;/p&gt;
&lt;p&gt;事件流有三个阶段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件捕获阶段&lt;/li&gt;
&lt;li&gt;处于目标阶段&lt;/li&gt;
&lt;li&gt;事件冒泡阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;事件捕获和事件冒泡&#34;&gt;事件捕获和事件冒泡&lt;/h2&gt;
&lt;p&gt;事件捕获：事件从最外层父元素到最里层子元素的顺序触发，如document &amp;gt; html &amp;gt; body &amp;gt; div &amp;gt; p。&lt;/p&gt;
&lt;p&gt;事件冒泡：事件从最里层子元素到最外层父元素的顺序触发，如p &amp;lt; div &amp;lt; body &amp;lt; html &amp;lt; document。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2021/01/24/9lXUHMgVYsBQaC1.png&#34; alt=&#34;v2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;因为有捕获和冒泡两种传播方式，W3C制定了一个标准可以让我们自己选择使用哪种传播方式。我们在使用addEventListener监听事件时，&lt;strong&gt;addEventListener(&amp;lsquo;click&amp;rsquo;,fn,bool)&lt;/strong&gt; ，如果第三个参数bool不传或者为falsy,那么我们会在冒泡阶段调用fn，如果第三个参数bool为true，那么我们会在捕获阶段调用fn。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2021/01/24/Yw5DC3IJnWtVTL9.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;target和currenttarget&#34;&gt;target和currentTarget&lt;/h2&gt;
&lt;p&gt;e.target为用户操作的元素&lt;/p&gt;
&lt;p&gt;e.currentTarget是程序员监听的元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div&amp;gt;
   &amp;lt;span&amp;gt;我是文字&amp;lt;/span&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假设我们监听的是div元素，但用户实际点击的是文字内容，那么&lt;/p&gt;
&lt;p&gt;e.target指向span元素&lt;/p&gt;
&lt;p&gt;e.currentTarget指向div元素&lt;/p&gt;
&lt;h2 id=&#34;eventstoppropagation阻止事件冒泡&#34;&gt;event.stopPropagation()阻止事件冒泡&lt;/h2&gt;
&lt;p&gt;当事件使用 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 方法将阻止事件冒泡到其父元素，代码示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;parent&amp;quot; style=&amp;quot;width: 200px; height: 200px; border: 1px solid springgreen;&amp;quot;&amp;gt;
        &amp;lt;div id=&amp;quot;son&amp;quot; style=&amp;quot;width: 100px; height: 100px; border: 1px solid blue;&amp;quot;&amp;gt;son&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        parent.addEventListener(&#39;click&#39;, () =&amp;gt; {
            console.log(&#39;我是parent&#39;);
        })
        son.addEventListener(&#39;click&#39;, (e) =&amp;gt; {
            console.log(&#39;我是son&#39;);
            e.stopPropagation(); // 中断事件冒泡
        })
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2021/01/24/7uHA39JYGsNl8FP.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;eventpreventdefault阻止默认事件&#34;&gt;event.preventDefault()阻止默认事件&lt;/h2&gt;
&lt;p&gt;如果调用这个方法，默认事件行为将不再触发。什么是默认事件？例如表单一点击提交按钮 &lt;code&gt;submit&lt;/code&gt; 跳转页面、 &lt;code&gt;a&lt;/code&gt; 标签默认页面跳转或是锚点定位等。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;给 &lt;code&gt;a&lt;/code&gt; 标签添加点击事件，当用户点击文字就阻止 &lt;code&gt;a&lt;/code&gt; 标签的默认页面跳转功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; &amp;lt;a href=&amp;quot;https://www.baidu.com&amp;quot; id=&amp;quot;x&amp;quot;&amp;gt;百度一下&amp;lt;/a&amp;gt;
    &amp;lt;script&amp;gt;
        x.addEventListener(&#39;click&#39;, (e) =&amp;gt; {
            e.preventDefault();
        })
    &amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2021/01/24/qkuZgpJWrvEyb3t.png&#34; alt=&#34;image.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;二事件委托&#34;&gt;二、事件委托&lt;/h1&gt;
&lt;p&gt;由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方法叫做事件委托。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;有一个div元素，div元素里有大量的button按钮，我们需要在点击每个button按钮的时候响应一个事件，怎么做？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;button&amp;gt;1&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;2&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;3&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;4&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;5&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;6&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;7&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;8&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;9&amp;lt;/button&amp;gt;
    &amp;lt;button&amp;gt;10&amp;lt;/button&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现的JS代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 监听父元素 div#container
container.addEventListener(&#39;click&#39;,(e)=&amp;gt;{
    const t = e.target
    if(t.matches(&#39;button&#39;)){
    console.log(&#39;点击了button&#39;)
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先监听父元素&lt;/li&gt;
&lt;li&gt;然后根据浏览器传进去的事件信息，拿到当前点击元素e.target&lt;/li&gt;
&lt;li&gt;再判断当前点击元素是不是button，如果是，就输出log语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述利用事件委托可以有效减少内存消耗，提高性能。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>jQuery</title>
      <link>http://localhost:1313/post/jquery/</link>
      <pubDate>Thu, 23 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/jquery/</guid>
      
        <description>&lt;h1 id=&#34;jquery&#34;&gt;jQuery&lt;/h1&gt;
&lt;h2 id=&#34;了解jquery&#34;&gt;了解jQuery&lt;/h2&gt;
&lt;p&gt;在三大框架(Vue, React, Angular)日益盛行的今天，jQuery的热度似乎已经逐渐消减。jQuery作为一个简单，经典的库，我们可以通过jQuery学习很多封装技巧，根据&lt;a href=&#34;https://trends.builtwith.com/javascript/jQuery&#34;&gt;Built width&lt;/a&gt;的统计，jQuery的使用数量仍在逐年上涨。jQuery作为一个封装良好的DOM库，jQuery能够如此流行还要归功于其良好的设计模式，使用起来相当便利，作为前端新人，通过学习jQuery，了解一些jQuery的设计思想，无论是对于今后学习其他框架，还是打牢js基础，都是很有必要的。&lt;/p&gt;
&lt;h2 id=&#34;jquery的使用方法&#34;&gt;jQuery的使用方法&lt;/h2&gt;
&lt;h3 id=&#34;使用jquery选择dom元素&#34;&gt;使用jQuery选择DOM元素&lt;/h3&gt;
&lt;p&gt;作为一个封装良好的DOM库，使用jQuery往往从选择一个DOM元素开始，然后对其进行某种操作。&lt;/p&gt;
&lt;p&gt;我们可以通过使用&lt;code&gt;jQuery()&lt;/code&gt;或者更加简洁的&lt;code&gt;$()&lt;/code&gt;来获取一个DOM元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;) // 获取页面所有div元素

$(&#39;.red&#39;) // 获取所有class包含red的元素

$(&#39;#red&#39;) // 获取id为red的元素

$(&#39;input[name=firstname]&#39;) // 获取name属性为firstname的input元素

$(&#39;a:first&#39;) // 获取页面中第一个a元素

$(&#39;li:odd&#39;) // 获取奇数li
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他选择方式，参见&lt;a href=&#34;https://www.jquery123.com/category/selectors/&#34;&gt;选择器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;操作dom元素&#34;&gt;操作DOM元素&lt;/h3&gt;
&lt;p&gt;jQuery的设计思想在于选择DOM元素，并对其进行操作，但由于DOM API的复杂性，使用jQuery选择DOM元素后并不会返回DOM对象，而是一个jQuery对象，通过操作jQuery对象，即可操作使用jQuery选中的DOM对象，这极大的方便了DOM元素的可操作性，也由于jQuery出色的封装，使得常用属性操作也非常方便。&lt;/p&gt;
&lt;h4 id=&#34;链式操作&#34;&gt;链式操作&lt;/h4&gt;
&lt;p&gt;正因为使用jQuery选择DOM后返回一个jQuery对象，所以我们可以使用链式操作，类似如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;.red&#39;) // 找到指定元素集合
  .find(&#39;li&#39;) // 找到集合中特定部分
  .eq(2) // 选择指定元素
  .text(&#39;Hello&#39;) // 对其进行操作
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;gettersetter&#34;&gt;getter/setter&lt;/h4&gt;
&lt;p&gt;在jQuery中，部分API会根据参数不同来改变API的行为，其中，比较方便的一项就是如果指定参数，就将API作为一个setter使用，将属性设置为指定的值；如果不传入参数，那就作为getter使用，返回元素指定属性的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;h1&#39;).text() // 返回h1的文本内容

$(&#39;h1&#39;).text(&#39;hello&#39;) // 设置h1的文本内容为hello
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;创建元素&#34;&gt;创建元素&lt;/h4&gt;
&lt;p&gt;使用jQuery，我们可以方便的创建元素&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;&amp;lt;div&amp;gt;Hello world&amp;lt;/div&amp;gt;&#39;) // 创建一个div元素
  .append($(&#39;.red&#39;)) // 插入指定元素集之后
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于使用jQuery创建DOM元素，更多信息可以查看&lt;a href=&#34;https://www.jquery123.com/jQuery/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他DOM操作，可以查看&lt;a href=&#34;https://www.jquery123.com/category/manipulation/&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;移动元素&#34;&gt;移动元素&lt;/h4&gt;
&lt;p&gt;通过jQuery提供的API的组合，我们可以移动一个DOM元素到指定的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;.red&#39;).insertAfter($(&#39;.green&#39;)) // 将class包含red的元素插入class包含green的元素之后

$(&#39;.green&#39;).after($(&#39;.red&#39;)) // 将class包含red的元素放在class包含green的后面
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似还有&lt;code&gt;.insertBefore()&lt;/code&gt;，&lt;code&gt;.before()&lt;/code&gt;，&lt;code&gt;.appendTo()&lt;/code&gt;，&lt;code&gt;.append()&lt;/code&gt;，&lt;code&gt;.prependTo()&lt;/code&gt;和&lt;code&gt;.prepend()&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;修改dom属性&#34;&gt;修改DOM属性&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;div&#39;).addClass(&#39;.red&#39;) // 给所有div添加样式类red

$(&#39;div&#39;).css({width: &#39;200px&#39;}) // 将所有div宽度设置为200px
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>JS函数执行的时机</title>
      <link>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA/</link>
      <pubDate>Fri, 10 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E6%97%B6%E6%9C%BA/</guid>
      
        <description>&lt;h1 id=&#34;js函数执行的时机&#34;&gt;JS函数执行的时机&lt;/h1&gt;
&lt;h2 id=&#34;一段代码&#34;&gt;一段代码&lt;/h2&gt;
&lt;p&gt;在讨论JS函数执行的时机之前，我们先来看一段代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let i = 0
for(i = 0; i&amp;lt;6; i++){
  setTimeout(()=&amp;gt;{
    console.log(i)
  },0)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行上述代码，最终控制台输出结果是什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setTimeout的id, 0, 1, 2, 3, 4, 5&lt;/li&gt;
&lt;li&gt;setTimeout的id, 6, 6, 6, 6, 6, 6&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可能有人会写出上述代码，并期望得到结果1，但实际控制台会输出结果2。&lt;/p&gt;
&lt;p&gt;本篇文章会分析js的执行过程，来分析为什么会输出结果2，涉及到了调用栈，作用域与闭包，以及event loop与macro task queue，并在最后提出几种能够得到结果2的方法。&lt;/p&gt;
&lt;h2 id=&#34;使用let关键字更改输出&#34;&gt;使用let关键字更改输出&lt;/h2&gt;
&lt;p&gt;这里的关键点，我认为有以下几点&lt;/p&gt;
&lt;p&gt;首先是setTimeout内回调函数的执行时间，其次是setTimeout内回调函数使用的i变量的作用域&lt;/p&gt;
&lt;p&gt;其实搞清i的作用域我们就知道，整个执行过程中，我们使用了一个i变量，并在最后输出6次i。&lt;/p&gt;
&lt;p&gt;那么如果不更改setTimeout内的代码，有没有办法记录下i的值，并在之后输出呢，也就是实现控制台输出0, 1, 2, 3, 4, 5的效果呢&lt;/p&gt;
&lt;p&gt;很显然，我们需要6个额外的变量来保存i每次循环时的值&lt;/p&gt;
&lt;p&gt;在ES6之前，js并没有块级作用域，但在ES6新出的&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;中，使用这两个关键字会自动将其所在的{}变更为一个新的作用域。&lt;/p&gt;
&lt;p&gt;而且为了记录for循环每次的i的值，js还额外做了一些工作，会将for循环的{}变成一个新的作用域。&lt;/p&gt;
&lt;p&gt;此时我们改写代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let i = 0; i &amp;lt; 6; i++) {
  setTimeout(() =&amp;gt; console.log(i))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了理解，我会将代码转化如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  let _i = 0
  while(_i &amp;lt; 6) {
    const i = _i
    setTimeout(() =&amp;gt; { console.log(i) })
    _i++
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时在js执行完毕后，根据作用域链，查找到for循环的{}内，因为每次执行都创建新的作用域，所以每一轮循环都会有一个“新的i”，也就是类似于js保存了i变量此时的快照，所以总共有6个i，并且在for循环外是访问不到的，也就是setTimeout内的&lt;code&gt;console.log(i)&lt;/code&gt;携带了一个闭包。&lt;/p&gt;
&lt;p&gt;关于闭包的定义及使用，如果有不清楚的小伙伴可以多查找一些资料。&lt;/p&gt;
&lt;p&gt;这里也推荐一个&lt;a href=&#34;https://www.youtube.com/playlist?list=PLWrQZnG8l0E4kd1T_nyuVoxQUaYEWFgcD&#34;&gt;系列视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既然我们通过使用&lt;code&gt;let&lt;/code&gt;关键字，来实现效果，并且其核心原理就是增加新的作用域，那么其实我们也可以使用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;来声明新变量的方式来实现同样的效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  const j = i
  setTimeout(() =&amp;gt; {
    console.log(j)
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我使用了&lt;code&gt;const&lt;/code&gt;关键字来声明j变量，以便更明确的标明j变量是一个新的变量。&lt;/p&gt;
&lt;h2 id=&#34;使用立即执行函数来创建作用域更改输出&#34;&gt;使用立即执行函数来创建作用域，更改输出&lt;/h2&gt;
&lt;p&gt;那么，如果不适用&lt;code&gt;let&lt;/code&gt;和&lt;code&gt;const&lt;/code&gt;关键字呢？&lt;/p&gt;
&lt;p&gt;我们可以使用立即执行函数来创建作用域&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  ;(function() {
    var j = i
    setTimeout(() =&amp;gt; {
      console.log(j)
    })
  })()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们不想修改&lt;code&gt;console.log(i)&lt;/code&gt;，还可以写为如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let i
for (i = 0; i &amp;lt; 6; i++) {
  ;(function(i) {
    setTimeout(() =&amp;gt; {
      console.log(i)
    })
  })(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时每执行一次循环，就会将i的值作为参数传递给立即执行函数，&lt;code&gt;console.log(i)&lt;/code&gt;中i的值也就在进入macro task queue前就已确定。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>JS对象</title>
      <link>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 03 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E5%AF%B9%E8%B1%A1/</guid>
      
        <description>&lt;h2 id=&#34;js对象&#34;&gt;JS对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对象的定义
&lt;ul&gt;
&lt;li&gt;无序的数据集合&lt;/li&gt;
&lt;li&gt;键值对的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;声明对象
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const obj = { &#39;name&#39;: &#39;Frank&#39;, &#39;age&#39;: 18 }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const obj = new Object({ &#39;name&#39;: &#39;Frank&#39; })&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log({ &#39;name&#39;: &#39;Frank&#39;, &#39;age&#39;: 18 })&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;细节
&lt;ul&gt;
&lt;li&gt;键名为字符串，不是标识符，可以包含任意字符&lt;/li&gt;
&lt;li&gt;引号可省略，省略后只能写标识符&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;即使省略引号，键名仍为字符串&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Object.keys()&lt;/code&gt;可获取对象的所有键名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用变量的值作为属性名
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const p1 = &#39;name&#39;&lt;/code&gt; 定义一个变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const obj = { p1: &#39;Frank&#39; } // { &#39;p1&#39;: &#39;Frank&#39; }&lt;/code&gt; 直接书写，键名为p1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const obj = { [p1]: &#39;Frank&#39; } // { &#39;name&#39;: &#39;Frank&#39; }&lt;/code&gt; 使用方括号包裹，键名为变量p1的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对比
&lt;ul&gt;
&lt;li&gt;不加[]的属性名会自动转换为字符串&lt;/li&gt;
&lt;li&gt;加了[]后会当做表达式求值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对象的隐藏属性
&lt;ul&gt;
&lt;li&gt;JS中每个对象都有一个隐藏属性&lt;/li&gt;
&lt;li&gt;这个隐藏属性存储着其共有属性和方法组成的对象的地址&lt;/li&gt;
&lt;li&gt;这个由其公共属性和方法组成的对象叫做原型&lt;/li&gt;
&lt;li&gt;也就是说每个对象都有一个隐藏属性，存储着其原型的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Symbol也可作为属性名
&lt;ul&gt;
&lt;li&gt;迭代时会使用&lt;/li&gt;
&lt;li&gt;可见&lt;a href=&#34;https://blingblingredstar.github.io/2019/05/02/JavaScript-The-Recent-Parts/#Data-Structure-Without-Iterators&#34;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;对象属性的增删改查&#34;&gt;对象属性的增删改查&lt;/h2&gt;
&lt;h3 id=&#34;删除属性&#34;&gt;删除属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;delete obj.propertyName
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete obj[&#39;propertyName&#39;]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;可以删除obj的propertyName属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不含属性名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;propertyName&#39; in obj === false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;含有属性，但值为undefined&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;property&#39; in obj &amp;amp;&amp;amp; obj.property === undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原型对象&#34;&gt;原型对象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个对象都有一个原型对象(使用Object.create(null)创建的除外)
&lt;ul&gt;
&lt;li&gt;原型对象保存着实例对象的共有属性和方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实例对象的原型对象也是对象
&lt;ul&gt;
&lt;li&gt;所以原型对象也有原型对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const obj = {}&lt;/code&gt;，obj的原型对象也是所有Object的实例对象的原型对象&lt;/li&gt;
&lt;li&gt;这个原型对象包含了所有对象的公共属性和方法，是对象的根&lt;/li&gt;
&lt;li&gt;这个原型对象的原型指向了null(原型链的最终指向)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查看属性&#34;&gt;查看属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看自身所有属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.keys(obj)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看自身属性 + 共有属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;console.dir(obj)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Object.keys()&lt;/code&gt;分别传入&lt;code&gt;obj&lt;/code&gt;和&lt;code&gt;obj.__proto__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断属性是否为自身属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj.hasOwnProperty(&#39;toString&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;in&lt;/code&gt;关键字，可以查看当前对象或者原型对象上是否有对应属性，使用&lt;code&gt;hasOwnProperty&lt;/code&gt;，可以查看当前对象上是否有特定属性(&amp;lsquo;name&amp;rsquo; in obj和obj.hasOwnProperty(&amp;lsquo;name&amp;rsquo;) 的区别是前者会查看当前对象或原型对象上是否有name，后者只会查看当前对象上是否有name)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看指定属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中括号语法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj[&#39;key&#39;]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;点语法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;obj.key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两种语法功能上没有区别，使用中括号语法，可以使用变量来访问属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;修改增加属性&#34;&gt;修改/增加属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;直接赋值
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const obj = { &#39;name&#39;: &#39;Frank&#39; }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj.name = &#39;Frank&#39; // name是字符串&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj[&#39;name&#39;] = &#39;Frank&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;obj[&#39;na&#39; + &#39;me&#39;] = &#39;Frank&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const key = &#39;name&#39;; obj[key] = &#39;Frank&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;批量赋值
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assign(obj, {&#39;age&#39;: 18, &#39;gender&#39;: &#39;man&#39;})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改/增加原型对象属性
&lt;ul&gt;
&lt;li&gt;无法通过自身修改或增加原型对象属性&lt;/li&gt;
&lt;li&gt;一般来说，不推荐修改原型&lt;/li&gt;
&lt;li&gt;如果要修改，通过构造函数的原型属性进行修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;修改原型对象
&lt;ul&gt;
&lt;li&gt;不推荐使用&lt;code&gt;__proto__&lt;/code&gt;属性进行修改&lt;/li&gt;
&lt;li&gt;在创建时直接使用&lt;code&gt;Object.create()&lt;/code&gt;，传入一个对象作为新建对象的原型对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>JS语法</title>
      <link>http://localhost:1313/post/js%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Thu, 02 Jan 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/js%E8%AF%AD%E6%B3%95/</guid>
      
        <description>&lt;h2 id=&#34;js语言&#34;&gt;JS语言&lt;/h2&gt;
&lt;h3 id=&#34;js版本&#34;&gt;JS版本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;历史版本
&lt;ul&gt;
&lt;li&gt;ES3 1999年&lt;/li&gt;
&lt;li&gt;ES5 2009年&lt;/li&gt;
&lt;li&gt;ES6 2015年&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;js语法&#34;&gt;JS语法&lt;/h2&gt;
&lt;h3 id=&#34;表达式与语句&#34;&gt;表达式与语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;表达式
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1+2&lt;/code&gt;这个表达式的值为3&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add(1, 2)&lt;/code&gt;这个表达式的值为函数&lt;code&gt;add&lt;/code&gt;的返回值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log&lt;/code&gt;表达式的值为函数本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log(3)&lt;/code&gt;表达式的值为&lt;code&gt;console.log&lt;/code&gt;的返回值，也就是&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语句
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var a = 1&lt;/code&gt;是一个语句&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;表达式与语句的区别
&lt;ul&gt;
&lt;li&gt;表达式一般都有值，语句不一定有&lt;/li&gt;
&lt;li&gt;语句一般会改变环境(声明、赋值)&lt;/li&gt;
&lt;li&gt;以上并不绝对&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;大小写敏感case-sensitive&#34;&gt;大小写敏感(Case Sensitive)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var a&lt;/code&gt;与&lt;code&gt;var A&lt;/code&gt;声明了两个不同变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object&lt;/code&gt;与&lt;code&gt;Object&lt;/code&gt;为两个不同变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;与&lt;code&gt;Function&lt;/code&gt;也是两个不同变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;空格与换行&#34;&gt;空格与换行&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不影响语义的情况下没有影响
&lt;ul&gt;
&lt;li&gt;return后不能加换行(因为自动分号插入机制)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标识符&#34;&gt;标识符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;规则
&lt;ul&gt;
&lt;li&gt;第一个字符，可以使Unicode字母或者&amp;amp;或_或者中文&lt;/li&gt;
&lt;li&gt;后面的字符可以再添加数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; 单行注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/**/&lt;/code&gt; 多行注释&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不好的注释
&lt;ul&gt;
&lt;li&gt;翻译代码的注释&lt;/li&gt;
&lt;li&gt;过时的注释&lt;/li&gt;
&lt;li&gt;无关的注释&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;好的注释
&lt;ul&gt;
&lt;li&gt;采坑注释&lt;/li&gt;
&lt;li&gt;为什么代码会这么写，遇到什么bug&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区块block&#34;&gt;区块block&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;把代码包裹在一起&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  let a = 1
  let b = 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;常与if/for/while/function合用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;if语句&#34;&gt;if语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if(表达式) {语句} else {语句}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;在语句只有一句时可省略，但不建议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;switch语句&#34;&gt;switch语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;switch(fruit) {
  case &#39;apple&#39;:
    //...
    break;
  case &#39;bananab&#39;:
    //...
    break;
  default:
    //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;三元表达式&#34;&gt;三元表达式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法
&lt;ul&gt;
&lt;li&gt;表达式 ？ 为真情况表达式 : 为假情况表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;短路逻辑&#34;&gt;&amp;amp;&amp;amp;短路逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a &amp;amp;&amp;amp; b &amp;amp;&amp;amp; c &amp;amp;&amp;amp; d&lt;/code&gt;取第一个假值或&lt;code&gt;d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;短路逻辑-1&#34;&gt;||短路逻辑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a || b || c || d&lt;/code&gt;取第一个真值或&lt;code&gt;d&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;while循环&#34;&gt;while循环&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法
&lt;ul&gt;
&lt;li&gt;while(表达式) {语句}&lt;/li&gt;
&lt;li&gt;首先判断表达式真假&lt;/li&gt;
&lt;li&gt;为真执行语句&lt;/li&gt;
&lt;li&gt;执行完语句，重新判断表达式真假&lt;/li&gt;
&lt;li&gt;表达式为假，跳出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;for循环&#34;&gt;for循环&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法糖
&lt;ul&gt;
&lt;li&gt;for是while的语法糖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;语法
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for(语句1; 表达式2; 语句三) { 循环体 }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;先执行语句1&lt;/li&gt;
&lt;li&gt;判断表达式2的真假&lt;/li&gt;
&lt;li&gt;如果为真，执行循环体，然后执行语句三&lt;/li&gt;
&lt;li&gt;如果为假，跳出循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;break和continue&#34;&gt;break和continue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;break
&lt;ul&gt;
&lt;li&gt;退出所有循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;continue
&lt;ul&gt;
&lt;li&gt;退出当前一次循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;label语句&#34;&gt;label语句&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;foo: {
  console.log(1)
  break foo
  console.log(&#39;本行不会输出&#39;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;考点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
  foo: 1
}
// 上面是什么？
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>开博客啦</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</link>
      <pubDate>Mon, 01 Jan 2018 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</guid>
      
        <description>&lt;p&gt;开博记录贴！ 11-02号开通blog&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>浅析MVC</title>
      <link>http://localhost:1313/post/%E6%B5%85%E6%9E%90mvc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/post/%E6%B5%85%E6%9E%90mvc/</guid>
      
        <description>&lt;h1 id=&#34;浅析mvc&#34;&gt;浅析MVC&lt;/h1&gt;
&lt;h2 id=&#34;mvc-三个对象分别做什么给出伪代码示例&#34;&gt;MVC 三个对象分别做什么，给出伪代码示例&lt;/h2&gt;
&lt;p&gt;MVC(Model-View-Controller)是一种架构模式，是一种思想理念，并不是一种技术，塔通过关注点分离鼓励改进应用程序组织&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;M-Model 用于封装与应用的业务逻辑相关的数据以及对数据的处理方法，会有一个或多个视图监听此模型，与数据有关的就放在M里面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let Model={
    data:{},
    create:{},
    delete:{},
    update(data){
        Object.assign(m.data,data)//用新数据替换旧数据
        eventBus.trigger(&#39;m:update&#39;)//eventBus触发&#39;m:update&#39;信息，通知View刷新界面
    },
    get:{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;V-View 实现了M里数据的展示，展现了Model的当前状态，当模型里的数据发生变化时，视图相应地会刷新自己，与视图相关地放在V里面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let View={
    el:el，
    html：&#39;&#39;//html
    init(){
        v.el://elments
    }，
    render(){
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;C-Controller 定义用户界面对用户输入地响应，起到承上启下的作用，用于控制应用的流程&lt;/p&gt;
&lt;p&gt;，除了M和V的内容放在C里面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let Controller={
    init(){
        v.init()
        v.render()
        c.autoBindEvents()
        eventBus.on(&#39;m:update&#39;,()=&amp;gt;{v.render()}
    }，
    events:{//hashtable},
    method(){
        data=data
        m.update(data)
    },
    autoBindEvents(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;eventbus有哪些api作用是&#34;&gt;EventBus有哪些API，作用是&lt;/h2&gt;
&lt;p&gt;EventBus的作用是用来实现对象间的通信&lt;/p&gt;
&lt;p&gt;EventBus基本的3个API是 on, trigger(emit),off, 作用分别是监听事件，触发事件，取消监听&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const eventBus = $(window) 
const m = {
  data: {
    ...
  },
  update(data) {
    eventBus.trigger(&#39;m:updated&#39;)
  }
}

const v = {
  render(data) {
    ...
  }
}  
  
const c = {
  eventBus.on(&#39;m:updated&#39;, () =&amp;gt; {
    v.render(m.data.n)
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;表驱动编程是做什么的&#34;&gt;表驱动编程是做什么的&lt;/h2&gt;
&lt;p&gt;表驱动编程是通过哈希表来优化代码，可以将大量重复的代码进行剥离，从而达到模块化的处理&lt;/p&gt;
&lt;p&gt;Before:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&#39;#el1&#39;).on(&#39;事件A&#39;, fn1)
$(&#39;#el2&#39;).on(&#39;事件B&#39;, fn2)
$(&#39;#el3&#39;).on(&#39;事件C&#39;, fn3)
$(&#39;#el4&#39;).on(&#39;事件D&#39;, fn4)
$(&#39;#el5&#39;).on(&#39;事件E&#39;, fn5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const events = {
  &amp;quot;#el1 事件A&amp;quot;: &amp;quot;fn1&amp;quot;,
  &amp;quot;#el2 事件B&amp;quot;: &amp;quot;fn2&amp;quot;,
  &amp;quot;#el3 事件C&amp;quot;: &amp;quot;fn3&amp;quot;,
  &amp;quot;#el4 事件D&amp;quot;: &amp;quot;fn4&amp;quot;,
  &amp;quot;#el5 事件E&amp;quot;: &amp;quot;fn5&amp;quot;
}

const eventFunctions = {
  fn1: function() {},
  fn2: function() {},
  fn3: function() {},
  fn4: function() {},
  fn5: function() {}
}

function autoBindEvents() {
  for(let key in events) {
    const spaceIndex = key.indexOf(&#39; &#39;)
    const el = key.splice(0, spaceIndex) 
    const event = key.splice(spaceIndex+1)
    const fn = eventFunctions[events[key]]
    $(el).on(event, fn)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;如何理解模块化的&#34;&gt;如何理解模块化的&lt;/h2&gt;
&lt;p&gt;我理解里的模块化是一种封装的思想，将大量的代码封装成几个模块，不同模块之间负责不同的工作，各个模块直接按协调完成一个项目，对于日后的优化和重构都非常重要&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
