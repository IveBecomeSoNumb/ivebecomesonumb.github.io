<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ay&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Ay&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 20 Dec 2020 16:01:23 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CSS知识总结</title>
      <link>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      
        <description>&lt;h1 id=&#34;css知识总结&#34;&gt;CSS知识总结&lt;/h1&gt;
&lt;h2 id=&#34;浏览器渲染原理&#34;&gt;浏览器渲染原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;步骤&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据HTML构建HTML树（DOM）&lt;/li&gt;
&lt;li&gt;根据CSS构建CSS树（CSSDOW）&lt;/li&gt;
&lt;li&gt;将两棵树合并成一颗渲染树(Render Tree)&lt;/li&gt;
&lt;li&gt;Layout布局（文档流、盒模型、计算大小和位置）&lt;/li&gt;
&lt;li&gt;Paint绘制（把边框颜色、文字颜色、阴影等画出来）&lt;/li&gt;
&lt;li&gt;Compose合成（根据层叠关系展示画面）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DOM,CSSOM,Render Tree&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/21/zlycZ8CeEsuRwYi.png&#34; alt=&#34;tree&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;transition和animationcss动画&#34;&gt;Transition和Animation（CSS动画）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;语法：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;transition: 属性名 时长 过渡方式 延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如： transition: all 2s ease 2s;&lt;/p&gt;
&lt;p&gt;其中过渡方式有: linear/ease/ease-in/ease-out/ease-in-out&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#heart{
  display: inline-block;
  margin: 100px;
  position: relative;
  transition: all 1s; 
}
#heart:hover{
  transform: scale(1.5); 
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;http://js.jirengu.com/nonud/1/edit?html,css,output&#34;&gt;代码1&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;animation:时长 过渡方式 延迟 次数 方向 填充模式 是否暂停 动画名&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如： animation: .5s heart infinite alternate-reverse;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#heart{
  display: inline-block;
  margin: 100px;
  position: relative;
  animation: .5s heart infinite alternate-reverse;
}
@keyframes heart {
  0%{
    transform: scale(1);
  }
  100%{
    transform: scale(1.2);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&#34;http://js.jirengu.com/hosug/1/edit?html,css,output&#34;&gt;代码2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;资料来源：饥人谷&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>HTML 常用标签</title>
      <link>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
      
        <description>&lt;h1 id=&#34;html-常用标签&#34;&gt;HTML 常用标签&lt;/h1&gt;
&lt;h2 id=&#34;a-标签111&#34;&gt;a 标签（11.1）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;网址&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://baidu.com&#34;&gt;http://baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://baidu.com&#34;&gt;https://baidu.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;//baidu.com (推荐这种，因为浏览器会自动适配网站)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;路径&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;/a/b/c 和 a/b/c 的区别： /a 是把当前 http 服务的根目录，如果不是用服务器打开而是双击打开.html 文件的话就会找不到文件; a 是在当前目录下找这个文件&lt;/li&gt;
&lt;li&gt;index.html 和./index.html 无区别&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;伪协议&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;javascript: ;&lt;/li&gt;
&lt;li&gt;id(#id 号)&lt;/li&gt;
&lt;li&gt;mailto:邮箱地址&lt;/li&gt;
&lt;li&gt;tel:手机号&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;target&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;_blank 新建空网站&lt;/li&gt;
&lt;li&gt;_top 顶部网站&lt;/li&gt;
&lt;li&gt;_self 当前网站&lt;/li&gt;
&lt;li&gt;_praent 父类网站&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;table-标签112&#34;&gt;table 标签（11.2）&lt;/h2&gt;
&lt;p&gt;thead 表头&lt;/p&gt;
&lt;p&gt;tbody 表体&lt;/p&gt;
&lt;p&gt;tfoot 表底&lt;/p&gt;
&lt;p&gt;tr 表换行&lt;/p&gt;
&lt;p&gt;th 表标题&lt;/p&gt;
&lt;p&gt;td 表数据&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;img-标签113&#34;&gt;img 标签（11.3）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;属性：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;alt/weight/height/src&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;onload/onerror&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;响应式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;max-width:100% (手机端可以有较好体验)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;小笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;table{&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;border-collapse:collapse;&lt;/p&gt;
&lt;p&gt;border-spacing:0;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;可以让表格合并，变好看一点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;input 和 button 区别：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;button 里面可以加其他标签，添加样式，input 不可以&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Java Collection</title>
      <link>http://localhost:1313/post/java-collection/</link>
      <pubDate>Sun, 20 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/java-collection/</guid>
      
        <description>&lt;h1 id=&#34;map集合和collection集合类总结&#34;&gt;Map集合和Collection集合类总结&lt;/h1&gt;
&lt;p&gt;Java的数组有很多弊端：长度固定，不可增删，只能存储同一种数据类型，数组内元素的内存空间是连续分配的，对内存要求高。 而Java中的集合弥补了这一点，在Java中的集合可以分为两大类&lt;code&gt;Collection&lt;/code&gt;和&lt;code&gt;map&lt;/code&gt;, 对此基于我们不同的需求可以产生不同的实现。&lt;/p&gt;
&lt;h1 id=&#34;collection单列集合&#34;&gt;Collection（单列集合）&lt;/h1&gt;
&lt;h3 id=&#34;list&#34;&gt;List&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;List接口是一个有序集合，允许有相同的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Arraylist是最常用的实现类，拥有线性结构，本质上就是一个数组，通过动态扩容实现添加元素（创建一个1.5x的空间，把原先的所有元素拷贝过去）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LinkedList底层为链表，特点是分配内存空间不是必须连续的、插入，删除操作也很快，只要修改前后指针，时间复杂度为O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;arraylist和linkedlist区别&#34;&gt;ArrayList和LinkedList区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ArrayList是实现&lt;strong&gt;基于动态数组&lt;/strong&gt;的数据结构，而LinkedList是&lt;strong&gt;基于链表&lt;/strong&gt;的数据结构&lt;/li&gt;
&lt;li&gt;对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList需要移动指针&lt;/li&gt;
&lt;li&gt;对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList需要移动数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;没有顺序，不能包含重复元素&lt;/p&gt;
&lt;h3 id=&#34;hashset&#34;&gt;HashSet&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashSet中不能包含重复元素，可以有NULL元素，存入的元素是无序的&lt;/li&gt;
&lt;li&gt;HashSet底层结构是哈希表，确认唯一性的两个方法是 HashCode()/equals()方法&lt;/li&gt;
&lt;li&gt;添加删除时间复杂度都是O（1）&lt;/li&gt;
&lt;li&gt;非线性安全&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;linkedhashset&#34;&gt;LinkedHashSet&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;LinkedHashSet中不能包含重复元素，可以有NULL元素，存入的元素是按照放入顺序排列&lt;/li&gt;
&lt;li&gt;底层结构是哈希表和链表，链表保证了数据存储和取出一致，哈希表保证了元素的唯一性&lt;/li&gt;
&lt;li&gt;添加删除时间复杂度都是O(1)&lt;/li&gt;
&lt;li&gt;非线性安全&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mapkey-value集合&#34;&gt;Map(key-value集合)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Map即为映射，不能有重复的key，可以有重复的value(例如ID和name)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hashmap&#34;&gt;HashMap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HashMap 是一个散列表，它存储的内容是键值对(key-value)映射&lt;/li&gt;
&lt;li&gt;HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口&lt;/li&gt;
&lt;li&gt;HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;treemap&#34;&gt;TreeMap&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;TreeMap 是一个有序的key-value集合，它是通过红黑树实现的&lt;/li&gt;
&lt;li&gt;TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合&lt;/li&gt;
&lt;li&gt;TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合&lt;/li&gt;
&lt;li&gt;TreeMap 实现了Cloneable接口，意味着它能被克隆&lt;/li&gt;
&lt;li&gt;TreeMap 实现了java.io.Serializable接口，意味着它支持序列化&lt;/li&gt;
&lt;li&gt;TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>HTML 入门笔记</title>
      <link>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
      <pubDate>Sat, 05 Dec 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
      
        <description>&lt;h1 id=&#34;html-入门笔记-1&#34;&gt;HTML 入门笔记 1&lt;/h1&gt;
&lt;p&gt;HTML = Hypertext Markup language 超文本标记语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超文本标记语言是一种用于创建网页的标准标记语言。HTML 是一种基础技术，常与 CSS、JavaScript 一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面。网页浏览器可以读取 HTML 文件，并将其渲染成可视化网页。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 发明者：Tim Berners Lee&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;李爵士自己做了一个浏览器，自己写了一个服务器，是前端工程师的祖师爷&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 起手式：Emmet ！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个 Index.html 文件，用 IDE 打开之后输入 &lt;code&gt;！+Tab&lt;/code&gt; , IDE 会补全代码，具体如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2020/12/18/MbIRh5ex8gda74y.png&#34; alt=&#34;Capture&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;lang=&amp;quot;en&amp;quot;&lt;/code&gt; 可以改成&lt;code&gt;lang = &amp;quot;zh-CN&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;HTML 常见章节标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;h1~h6: 标题 1-标题 6 数字越大字越小&lt;/li&gt;
&lt;li&gt;section：章节&lt;/li&gt;
&lt;li&gt;acticle: 文章&lt;/li&gt;
&lt;li&gt;main：主要内容&lt;/li&gt;
&lt;li&gt;aside: 旁支内容&lt;/li&gt;
&lt;li&gt;p：段落&lt;/li&gt;
&lt;li&gt;header,footer：头部和尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 全局属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class 类&lt;/li&gt;
&lt;li&gt;contenteditable 可编辑&lt;/li&gt;
&lt;li&gt;hidden 隐藏&lt;/li&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;style 样式&lt;/li&gt;
&lt;li&gt;tabindex：为数字，一般数字大小决定按 Tab 后选中顺序，-1 为永不选中，0 为最后选中&lt;/li&gt;
&lt;li&gt;title 鼠标移上去显示的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;HTML 常用内容标签：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 链接&lt;/li&gt;
&lt;li&gt;em 语气强调&lt;/li&gt;
&lt;li&gt;strong 重点强调&lt;/li&gt;
&lt;li&gt;code 显示代码&lt;/li&gt;
&lt;li&gt;pre 显示空白符&lt;/li&gt;
&lt;li&gt;q 引用&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Mavren 和Java 包管理区别</title>
      <link>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 05 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</guid>
      
        <description>&lt;h1 id=&#34;jvm工作原理&#34;&gt;JVM工作原理&lt;/h1&gt;
&lt;p&gt;首先，我们先来了解一下JVM的工作原理，其实简单地概括性地说，JVM只会做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行一个类的字节码&lt;/li&gt;
&lt;li&gt;在执行这个类的字节码的时候，若碰到了新的类，则加载它&lt;/li&gt;
&lt;li&gt;不断重复以上两个过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见，JVM的工作是如此的简单和枯燥，可是JVM是怎么知道在哪里读取这些类的呢？
JVM是通过&lt;code&gt;classpath&lt;/code&gt;参数来获取到这个路径的。
你没有给JVM传递classpath这个参数，但是你的编译器偷偷帮你干了这件事情了！&lt;/p&gt;
&lt;p&gt;每次用编译器编译的时候，控制台都会有一串命令，在命令里面你可以清楚地看到编译器给JVM偷偷传递了&lt;code&gt;classpath&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;另外，由于一个包有可能又依赖于其他很多个包，因此一个项目下来，可能&lt;code&gt;classpath&lt;/code&gt;下的依赖路径会变得又臭又长。
在Java刚诞生的时候，人们是需要通过手写这些&lt;code&gt;classpath&lt;/code&gt;路径来让JVM读懂读取jar包（一堆类的集合）的路径的，后面再人们的不断努力下，强大的IDEA和Maven的诞生，才让这个繁琐的过程变得无比简单&lt;/p&gt;
&lt;h1 id=&#34;classpath-hell&#34;&gt;Classpath hell&lt;/h1&gt;
&lt;p&gt;在Maven诞生之前，依赖冲突是一个很容易发生且很难解决的问题，我们把这种依赖冲突又称为&lt;code&gt;classpath hell&lt;/code&gt;（也叫依赖地狱）
什么是依赖冲突，由于全限定类名是类的唯一标示，因此当多个同名类不同版本同时出现在classpath的时候，就是噩梦的开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图，A包依赖了B包和C2包，而B包又依赖了C1包，在这个时候，由于所有的依赖包的路径都会写在classpath上面，让JVM从前往后地在这些路径上面寻早需要的依赖包，因此，若JVM先读取到了C1依赖包的classpath路径，那么C2这个依赖包，由于和C1只是版本上面的不同，因此JVM会误把C1路径中找到的依赖包也同样作用在C2上面，从而导致出现不可预期的错误。
一般来说，当你看到你的代码在编译运行之后，出现了以下的错误，那就代表最麻烦的包冲突出现了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AbstractMethodError&lt;/li&gt;
&lt;li&gt;NoClassDefFoundError&lt;/li&gt;
&lt;li&gt;ClassNotFoundException&lt;/li&gt;
&lt;li&gt;LinkageError&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;maven包管理的原理&#34;&gt;Maven包管理的原理&lt;/h1&gt;
&lt;p&gt;在Maven没有诞生之前，包冲突只能通过手动寻找冲突的包依赖，并把对应的包进行升级或者替换，但问题是，一个项目一般存在着很多很多的包依赖，手动寻找费时费力，效率太低。直到后来Maven的诞生，才使得解决包依赖的解决变得不再那么麻烦。&lt;/p&gt;
&lt;p&gt;首先我们先来了解一下Maven是如何对包进行管理的
我们需要首先知道的是，Maven有一套约定俗成的规范，其中规定了，生产代码需要放在&lt;code&gt;src/main&lt;/code&gt;目录下面，而测试代码则需要放在test/main目录下面。这个将在之后讲包管理的scope中有用。&lt;/p&gt;
&lt;p&gt;Maven会有中央仓库和本地仓库两个仓库
本地仓库即字面意思在本地你电脑中存在的仓库，它默认位于&lt;code&gt;~/.m2&lt;/code&gt;目录中，里面会放置一些经过下载的第三方包的缓存。
而中央仓库即线上仓库的意思，一个包会含有&lt;code&gt;groupId&lt;/code&gt;、&lt;code&gt;artifactId&lt;/code&gt;、&lt;code&gt;version&lt;/code&gt;三个字段，因此在中央仓库中，一个包存放的路径也是以这三个字段来存放的，具体会存放在&lt;code&gt;groupId/artifactId/version&lt;/code&gt;这个位置。&lt;/p&gt;
&lt;p&gt;当一个项目需要使用一些第三方包的时候，你可以在pom文件中添加这些包的信息，这样Maven就会自动帮你下载这些包以及其相关依赖包到本地中缓存起来&lt;/p&gt;
&lt;h1 id=&#34;maven如何解决包冲突&#34;&gt;Maven如何解决包冲突&lt;/h1&gt;
&lt;p&gt;解决包冲突的一个原则：绝对不允许最终的classpath出现同名不同版本的jar包&lt;/p&gt;
&lt;p&gt;在Maven中，当出现包冲突的问题的时候，Maven会保留离项目最近的包，而去除其他有冲突的包，拿之前的例子来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。但是这种策略有时候是不完美的，因此有时候也需要我们人为地去维护它，但不管怎么说，由于Maven的诞生，使得我们对于第三方包的很多操作都变得轻松和简单了。&lt;/p&gt;
&lt;p&gt;接下来我们来说一下人为解决冲突的三种办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接依赖高版本依赖，这样Maven就能去除所有低版本的不合适的依赖了&lt;/li&gt;
&lt;li&gt;通过pom文件来排除包中的后代指定依赖&lt;/li&gt;
&lt;li&gt;通过Maven helper插件来解决包冲突问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pom文件中，可以通过设置scope标签，来指定一个包是否可以被生产代码和测试代码所引用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;complie（生产代码以及测试代码均可见）&lt;/li&gt;
&lt;li&gt;test（只有测试代码可见）&lt;/li&gt;
&lt;li&gt;provided（只在编译的生产代码的时候生效，在运行时无效）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>如何用 hugo 搭建个人博客</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 02 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;h1 id=&#34;步骤1安装-hugo&#34;&gt;步骤1：安装 hugo&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;brew install hugo
# or
port install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认你的安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤2-创建新网站&#34;&gt;步骤2: 创建新网站&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new site quickstart
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤3-添加主题&#34;&gt;步骤3: 添加主题&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cd quickstart
git init
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤4-添加内容&#34;&gt;步骤4： 添加内容&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/&amp;lt;name&amp;gt;.md
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤5-开始hugo-server&#34;&gt;步骤5: 开始hugo server&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo server -D
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;新站点是http://localhost:1313/.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;步骤6自定义你的主题&#34;&gt;步骤6：自定义你的主题&lt;/h1&gt;
&lt;p&gt;打开config.toml文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseURL = &amp;quot;https://example.org/&amp;quot;    #你的github个人主页
languageCode = &amp;quot;en-us&amp;quot;              #语言
title = &amp;quot;My New Hugo Site&amp;quot;          #标题
theme = &amp;quot;ananke&amp;quot;                    #主题
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤7-创建静态页面&#34;&gt;步骤7： 创建静态页面&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo -D
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤8创建github个人页面仓库&#34;&gt;步骤8：创建Github个人页面仓库&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;创建新仓库名为 &amp;lt;你的github名&amp;gt;.github.io&lt;/li&gt;
&lt;li&gt;在public文件中使用cmder运行：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git init
git add .
git commit -v/m
git remote xxxx
git push xxxx
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>开博客啦</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</link>
      <pubDate>Mon, 01 Jan 2018 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</guid>
      
        <description>&lt;p&gt;开博记录贴！ 11-02号开通blog&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
