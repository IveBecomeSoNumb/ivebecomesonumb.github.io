<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jane - A super concise theme for Hugo</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Jane - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 05 Nov 2020 16:01:23 +0800</lastBuildDate>
    
        <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;
&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Mavren 和Java 包管理区别</title>
      <link>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 05 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/mavren-%E5%92%8Cjava-%E5%8C%85%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB/</guid>
      
        <description>&lt;h1 id=&#34;jvm工作原理&#34;&gt;JVM工作原理&lt;/h1&gt;
&lt;p&gt;首先，我们先来了解一下JVM的工作原理，其实简单地概括性地说，JVM只会做两件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行一个类的字节码&lt;/li&gt;
&lt;li&gt;在执行这个类的字节码的时候，若碰到了新的类，则加载它&lt;/li&gt;
&lt;li&gt;不断重复以上两个过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见，JVM的工作是如此的简单和枯燥，可是JVM是怎么知道在哪里读取这些类的呢？
JVM是通过&lt;code&gt;classpath&lt;/code&gt;参数来获取到这个路径的。
你没有给JVM传递classpath这个参数，但是你的编译器偷偷帮你干了这件事情了！&lt;/p&gt;
&lt;p&gt;每次用编译器编译的时候，控制台都会有一串命令，在命令里面你可以清楚地看到编译器给JVM偷偷传递了&lt;code&gt;classpath&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;另外，由于一个包有可能又依赖于其他很多个包，因此一个项目下来，可能&lt;code&gt;classpath&lt;/code&gt;下的依赖路径会变得又臭又长。
在Java刚诞生的时候，人们是需要通过手写这些&lt;code&gt;classpath&lt;/code&gt;路径来让JVM读懂读取jar包（一堆类的集合）的路径的，后面再人们的不断努力下，强大的IDEA和Maven的诞生，才让这个繁琐的过程变得无比简单&lt;/p&gt;
&lt;h1 id=&#34;classpath-hell&#34;&gt;Classpath hell&lt;/h1&gt;
&lt;p&gt;在Maven诞生之前，依赖冲突是一个很容易发生且很难解决的问题，我们把这种依赖冲突又称为&lt;code&gt;classpath hell&lt;/code&gt;（也叫依赖地狱）
什么是依赖冲突，由于全限定类名是类的唯一标示，因此当多个同名类不同版本同时出现在classpath的时候，就是噩梦的开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图，A包依赖了B包和C2包，而B包又依赖了C1包，在这个时候，由于所有的依赖包的路径都会写在classpath上面，让JVM从前往后地在这些路径上面寻早需要的依赖包，因此，若JVM先读取到了C1依赖包的classpath路径，那么C2这个依赖包，由于和C1只是版本上面的不同，因此JVM会误把C1路径中找到的依赖包也同样作用在C2上面，从而导致出现不可预期的错误。
一般来说，当你看到你的代码在编译运行之后，出现了以下的错误，那就代表最麻烦的包冲突出现了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AbstractMethodError&lt;/li&gt;
&lt;li&gt;NoClassDefFoundError&lt;/li&gt;
&lt;li&gt;ClassNotFoundException&lt;/li&gt;
&lt;li&gt;LinkageError&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;maven包管理的原理&#34;&gt;Maven包管理的原理&lt;/h1&gt;
&lt;p&gt;在Maven没有诞生之前，包冲突只能通过手动寻找冲突的包依赖，并把对应的包进行升级或者替换，但问题是，一个项目一般存在着很多很多的包依赖，手动寻找费时费力，效率太低。直到后来Maven的诞生，才使得解决包依赖的解决变得不再那么麻烦。&lt;/p&gt;
&lt;p&gt;首先我们先来了解一下Maven是如何对包进行管理的
我们需要首先知道的是，Maven有一套约定俗成的规范，其中规定了，生产代码需要放在&lt;code&gt;src/main&lt;/code&gt;目录下面，而测试代码则需要放在test/main目录下面。这个将在之后讲包管理的scope中有用。&lt;/p&gt;
&lt;p&gt;Maven会有中央仓库和本地仓库两个仓库
本地仓库即字面意思在本地你电脑中存在的仓库，它默认位于&lt;code&gt;~/.m2&lt;/code&gt;目录中，里面会放置一些经过下载的第三方包的缓存。
而中央仓库即线上仓库的意思，一个包会含有&lt;code&gt;groupId&lt;/code&gt;、&lt;code&gt;artifactId&lt;/code&gt;、&lt;code&gt;version&lt;/code&gt;三个字段，因此在中央仓库中，一个包存放的路径也是以这三个字段来存放的，具体会存放在&lt;code&gt;groupId/artifactId/version&lt;/code&gt;这个位置。&lt;/p&gt;
&lt;p&gt;当一个项目需要使用一些第三方包的时候，你可以在pom文件中添加这些包的信息，这样Maven就会自动帮你下载这些包以及其相关依赖包到本地中缓存起来&lt;/p&gt;
&lt;h1 id=&#34;maven如何解决包冲突&#34;&gt;Maven如何解决包冲突&lt;/h1&gt;
&lt;p&gt;解决包冲突的一个原则：绝对不允许最终的classpath出现同名不同版本的jar包&lt;/p&gt;
&lt;p&gt;在Maven中，当出现包冲突的问题的时候，Maven会保留离项目最近的包，而去除其他有冲突的包，拿之前的例子来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAACiCAMAAAATIHpEAAAAe1BMVEX///8AAACIiIirq6vr6+u+vr7g4OD6+vouLi719fVMTEzk5OT5+fnU1NRkZGTy8vJdXV1paWnPz885OTm3t7eRkZFWVlaxsbE/Pz/JycmGhoZzc3OhoaGAgIAeHh4yMjIRERF3d3cmJiafn5+Xl5dISEgODg4+Pj4gICCDaAB+AAAEjUlEQVR4nO3d23KqMBQGYBZyEDmDgIgCWm19/yfcgNICuotkbATm/26UtNMwq0BCVgKCAAAAAAAAAAAAAAAAAAAAAAD/E8sFU+VZpbYOxJ1Zb9lriWflr3Khyp5fjR9FdSlRdg2XTLTmV/frLFeCaigJHXhVGFCoFx8RkSEIhksJybyqfqUibqUVcTpVTQqvX2TaCoKTK9Kk4xaQzac+l+rLmVz8p4qQKZOOm0Wc6qsPt2+TjltEH39Wg6Q1NnQ6dX480bhl6eHgphS1Cs3F60R7Cn6uAWanpunEzd1smptZblnOhjZes1Deiq9jkat//2Xvrtcxkbh5RGZz+3qe2g7Ff1WjrjQ2Jnq8Ff2luH2BubULQupz2QG77H20TCFuEYndojpuCacO3OexUzD+uOl+pt8V1nFbceqIiFRfSdNF9TH6uIm0eFB6i1tMLp+9sCm/9kv2txZCH3fcYrK0R+XZRjFN+UCfnO4Xih2hSJe8kJJiwzQVmXaKeX8ejINm/a+9vI6HfIoGt30x/arKXfFVopvuTcRILO7bg5pUengk/h3Ji5VG7QVeB/sgSuaP9TwYs+1dVxP6FQ0l57NwDor7J6//t6BjQcG7d2GClOMG7cFw+2kmit4spoRfV3Y27LA9ygZPWdyN4kM/5Xie5NSBN0N7wEKmhOskmXmwwxztwXA7tAcMzMsK7cFg6mHcA/UjJdMB7cFg0ipFezDcxx9OJ5ovMw3RHgymTnSC7JutaY/2YDDpfFT6fws6TlXWG4Yx83CUee5xM5K/myI5Y2ueS4NmQzov0R70k5L28qng4RRA6DpRa7qCkaA9eEruLjlNI52VmGJu687mxCJBwRVtsGqtxFf27t2YnB0pZQoeA5MDLcslQBr6uQPdloLxWgg0GweKymdVBI3pCzhl+xn12gha1UUav6cvTFdEsmoUhC19zzpV3RwzUHt81Qv1lOailzX6c79rRGvTXOooLUPMQ/3F/ufsjNqJKxFLE35x/rmh1/z2GmsPqxPYGGGGhDOTHXLObJRq2TAMlxAyDUxkJJ/Z2P4KS0yZBEhBszHvHp8DT1GdI+70mSzw+AE2emphRJjJHrkbNjHWGbHRzl/I6zP5wJ0+GwVJG0buJ7pyTJC0YSQtQ3TlmIjoyrFB0oaRuloiacNkhweJsNF5PZR3dpC0YSRjBTkb2z8jacMESRtGJqZUs1GdFHf6TCIkbdjoFwd3+kyQtGGEpA0j7ew/TtqYCRH5u+pEVrflayQwc7jlcdLmRCRGu5DSIqrqkbbrRY7kTluZtOlO31+TU33KtCnHO6uIXXLOOzZ6bpZ2Akfp7ct+ZQvH6+utToSxu45l510zciuJY1yvgDvErUtZt+O2fRQih9frUKcrfBAiE8mJXpvuC/vK11rdl0HH+dIt0QlXt353lzKz6shBj4DaY0weZVig+QTvOwMhlTkchXwMnDzlQrcEhFVe1vIcR9tzPLre7gflcLqIxOHTIiIrOORlktoovjqlELmcfpL4lS/dMlKa5VoVByNJAAAAAAAAAAAAAAAAAPBO/wB7QSxZU7dgSQAAAABJRU5ErkJggg==&#34; alt=&#34;classpath hell&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比于C1来说，C2这个第三方包离项目更接近，因此Maven会自动帮你把C1去除，而保留C2。但是这种策略有时候是不完美的，因此有时候也需要我们人为地去维护它，但不管怎么说，由于Maven的诞生，使得我们对于第三方包的很多操作都变得轻松和简单了。&lt;/p&gt;
&lt;p&gt;接下来我们来说一下人为解决冲突的三种办法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接依赖高版本依赖，这样Maven就能去除所有低版本的不合适的依赖了&lt;/li&gt;
&lt;li&gt;通过pom文件来排除包中的后代指定依赖&lt;/li&gt;
&lt;li&gt;通过Maven helper插件来解决包冲突问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pom文件中，可以通过设置scope标签，来指定一个包是否可以被生产代码和测试代码所引用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;complie（生产代码以及测试代码均可见）&lt;/li&gt;
&lt;li&gt;test（只有测试代码可见）&lt;/li&gt;
&lt;li&gt;provided（只在编译的生产代码的时候生效，在运行时无效）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>如何用 hugo 搭建个人博客</title>
      <link>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 02 Nov 2020 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%A6%82%E4%BD%95%E7%94%A8-hugo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>&lt;h1 id=&#34;步骤1安装-hugo&#34;&gt;步骤1：安装 hugo&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;brew install hugo
# or
port install hugo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确认你的安装：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hugo version
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤2-创建新网站&#34;&gt;步骤2: 创建新网站&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new site quickstart
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤3-添加主题&#34;&gt;步骤3: 添加主题&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;cd quickstart
git init
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
echo &#39;theme = &amp;quot;ananke&amp;quot;&#39; &amp;gt;&amp;gt; config.toml
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤4-添加内容&#34;&gt;步骤4： 添加内容&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo new posts/&amp;lt;name&amp;gt;.md
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤5-开始hugo-server&#34;&gt;步骤5: 开始hugo server&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo server -D
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;新站点是http://localhost:1313/.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;步骤6自定义你的主题&#34;&gt;步骤6：自定义你的主题&lt;/h1&gt;
&lt;p&gt;打开config.toml文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;baseURL = &amp;quot;https://example.org/&amp;quot;    #你的github个人主页
languageCode = &amp;quot;en-us&amp;quot;              #语言
title = &amp;quot;My New Hugo Site&amp;quot;          #标题
theme = &amp;quot;ananke&amp;quot;                    #主题
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤7-创建静态页面&#34;&gt;步骤7： 创建静态页面&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;hugo -D
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;步骤8创建github个人页面仓库&#34;&gt;步骤8：创建Github个人页面仓库&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;创建新仓库名为 &amp;lt;你的github名&amp;gt;.github.io&lt;/li&gt;
&lt;li&gt;在public文件中使用cmder运行：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git init
git add .
git commit -v/m
git remote xxxx
git push xxxx
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>开博客啦</title>
      <link>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</link>
      <pubDate>Mon, 01 Jan 2018 16:01:23 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BC%80%E5%8D%9A%E5%95%A6/</guid>
      
        <description>&lt;p&gt;开博记录贴！ 11-02号开通blog&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
